# Feel free to delete these first few references, which are specific to the template:

@book{hume48,
  author    = "David Hume",
  year      = "1748",
  title     = "An enquiry concerning human understanding",
  address   = "Indianapolis, IN",
  publisher = "Hackett",
  doi       = {https://doi.org/10.1017/CBO9780511808432},
}

@article{Atr03,
  author  = "P Atreides",
  year    = "2003",
  title   = "How to catch a sandworm",
  journal = "Transactions on Terraforming",
  volume  = 21,
  issue   = 3,
  pages   = {261-300}
}

@misc{terradesert,
  author  = {{TerraDesert Team}},
  title   = {Code for terraforming a desert},
  year    = {2000},
  url     = {https://terradesert.com/code/},
  note    = {Accessed 1 Jan. 2000}
}

# These references may be helpful:

@inproceedings{jupyter,
  abstract  = {It is increasingly necessary for researchers in all fields to write computer code, and in order to reproduce research results, it is important that this code is published. We present Jupyter notebooks, a document format for publishing code, results and explanations in a form that is both readable and executable. We discuss various tools and use cases for notebook documents.},
  author    = {Kluyver, Thomas and Ragan-Kelley, Benjamin and Pérez, Fernando and Granger, Brian and Bussonnier, Matthias and Frederic, Jonathan and Kelley, Kyle and Hamrick, Jessica and Grout, Jason and Corlay, Sylvain and Ivanov, Paul and Avila, Damián and Abdalla, Safia and Willing, Carol and {Jupyter development team}},
  editor    = {Loizides, Fernando and Scmidt, Birgit},
  location  = {Netherlands},
  publisher = {IOS Press},
  url       = {https://eprints.soton.ac.uk/403913/},
  booktitle = {Positioning and Power in Academic Publishing: Players, Agents and Agendas},
  year      = {2016},
  pages     = {87--90},
  title     = {Jupyter Notebooks - a publishing format for reproducible computational workflows},
}

@article{matplotlib,
  abstract     = {Matplotlib is a 2D graphics package used for Python for application development, interactive scripting, and publication-quality image generation across user interfaces and operating systems.},
  author       = {Hunter, J. D.},
  publisher    = {IEEE COMPUTER SOC},
  year         = {2007},
	doi          = {https://doi.org/10.1109/MCSE.2007.55},
  journal      = {Computing in Science \& Engineering},
  number       = {3},
  pages        = {90--95},
  title        = {Matplotlib: A 2D graphics environment},
  volume       = {9},
}

@article{numpy,
  author       = {Harris, Charles R. and Millman, K. Jarrod and van der Walt, Stéfan J. and Gommers, Ralf and Virtanen, Pauli and Cournapeau, David and Wieser, Eric and Taylor, Julian and Berg, Sebastian and Smith, Nathaniel J. and Kern, Robert and Picus, Matti and Hoyer, Stephan and van Kerkwijk, Marten H. and Brett, Matthew and Haldane, Allan and del Río, Jaime Fernández and Wiebe, Mark and Peterson, Pearu and Gérard-Marchant, Pierre and Sheppard, Kevin and Reddy, Tyler and Weckesser, Warren and Abbasi, Hameer and Gohlke, Christoph and Oliphant, Travis E.},
  publisher    = {Springer Science and Business Media {LLC}},
  doi          = {https://doi.org/10.1038/s41586-020-2649-2},
  date         = {2020-09},
  year         = {2020},
  journal      = {Nature},
  number       = {7825},
  pages        = {357--362},
  title        = {Array programming with {NumPy}},
  volume       = {585},
}

@misc{pandas1,
  author    = {{The Pandas Development Team}},
  title     = {pandas-dev/pandas: Pandas},
  month     = feb,
  year      = {2020},
  publisher = {Zenodo},
  version   = {latest},
  url       = {https://doi.org/10.5281/zenodo.3509134},
}

@inproceedings{pandas2,
  author    = {Wes McKinney},
  title     = {{D}ata {S}tructures for {S}tatistical {C}omputing in {P}ython},
  booktitle = {{P}roceedings of the 9th {P}ython in {S}cience {C}onference},
  pages     = {56 - 61},
  year      = {2010},
  editor    = {{S}t\'efan van der {W}alt and {J}arrod {M}illman},
	doi       = {https://doi.org/10.25080/Majora-92bf1922-00a},
}

@article{scipy,
  author  = {Virtanen, Pauli and Gommers, Ralf and Oliphant, Travis E. and
            Haberland, Matt and Reddy, Tyler and Cournapeau, David and
            Burovski, Evgeni and Peterson, Pearu and Weckesser, Warren and
            Bright, Jonathan and {van der Walt}, St{\'e}fan J. and
            Brett, Matthew and Wilson, Joshua and Millman, K. Jarrod and
            Mayorov, Nikolay and Nelson, Andrew R. J. and Jones, Eric and
            Kern, Robert and Larson, Eric and Carey, C J and
            Polat, {\.I}lhan and Feng, Yu and Moore, Eric W. and
            {VanderPlas}, Jake and Laxalde, Denis and Perktold, Josef and
            Cimrman, Robert and Henriksen, Ian and Quintero, E. A. and
            Harris, Charles R. and Archibald, Anne M. and
            Ribeiro, Ant{\^o}nio H. and Pedregosa, Fabian and
            {van Mulbregt}, Paul and {SciPy 1.0 Contributors}},
  title   = {{{SciPy} 1.0: Fundamental Algorithms for Scientific
            Computing in Python}},
  journal = {Nature Methods},
  year    = {2020},
  volume  = {17},
  pages   = {261--272},
  adsurl  = {https://rdcu.be/b08Wh},
	doi     = {https://doi.org/10.1038/s41592-019-0686-2},
}

@article{sklearn1,
  author       = {Pedregosa, F. and Varoquaux, G. and Gramfort, A. and Michel, V. and Thirion, B. and Grisel, O. and Blondel, M. and Prettenhofer, P. and Weiss, R. and Dubourg, V. and Vanderplas, J. and Passos, A. and Cournapeau, D. and Brucher, M. and Perrot, M. and Duchesnay, E.},
  year         = {2011},
  journal      = {Journal of Machine Learning Research},
  pages        = {2825--2830},
  title        = {Scikit-learn: Machine Learning in {P}ython},
  volume       = {12},
}

@inproceedings{sklearn2,
  author    = {Buitinck, Lars and Louppe, Gilles and Blondel, Mathieu and Pedregosa, Fabian and Mueller, Andreas and Grisel, Olivier and Niculae, Vlad and Prettenhofer, Peter and Gramfort, Alexandre and Grobler, Jaques and Layton, Robert and VanderPlas, Jake and Joly, Arnaud and Holt, Brian and Varoquaux, Gaël},
  booktitle = {ECML PKDD Workshop: Languages for Data Mining and Machine Learning},
  year      = {2013},
  pages     = {108--122},
  title     = {{API} design for machine learning software: experiences from the scikit-learn project},
}

@report{WebAssemblyCoreSpecification1,
  title = {{WebAssembly Core Specification}},
  version = {1.0},
  editor = {Rossberg, Andreas},
  date = {2019-12-05},
  institution = {{W3C}},
  url = {https://www.w3.org/TR/wasm-core-1/},
  langid = {english}
}

@report{WebAssemblyCoreSpecification2,
  title = {{WebAssembly Core Specification}},
  version = {2.0},
  editor = {Rossberg, Andreas},
  date = {2022-04-19},
  institution = {{W3C}},
  url = {https://www.w3.org/TR/wasm-core-2/},
  langid = {english},
  note = {https://webassembly.github.io/spec/core/_download/WebAssembly.pdf}
}

@inproceedings{10.1145/2048147.2048224,
author = {Zakai, Alon},
title = {Emscripten: an LLVM-to-JavaScript compiler},
year = {2011},
isbn = {9781450309424},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2048147.2048224},
doi = {10.1145/2048147.2048224},
abstract = {We present Emscripten, a compiler from LLVM (Low Level Virtual Machine) assembly to JavaScript. This opens up two avenues for running code written in languages other than JavaScript on the web: (1) Compile code directly into LLVM assembly, and then compile that into JavaScript using Emscripten, or (2) Compile a language's entire runtime into LLVM and then JavaScript, as in the previous approach, and then use the compiled runtime to run code written in that language. For example, the former approach can work for C and C++, while the latter can work for Python; all three examples open up new opportunities for running code on the web.Emscripten itself is written in JavaScript and is available under the MIT license (a permissive open source license), at http://www.emscripten.org. As a compiler from LLVM to JavaScript, the challenges in designing Emscripten are somewhat the reverse of the norm - one must go from a low-level assembly into a high-level language, and recreate parts of the original high-level structure of the code that were lost in the compilation to low-level LLVM. We detail the methods used in Emscripten to deal with those challenges, and in particular present and prove the validity of Emscripten's Relooper algorithm, which recreates high-level loop structures from low-level branching data.},
booktitle = {Proceedings of the ACM International Conference Companion on Object Oriented Programming Systems Languages and Applications Companion},
pages = {301–312},
numpages = {12},
keywords = {llvm, javascript, decompiler},
location = {Portland, Oregon, USA},
series = {OOPSLA '11}
}

@inproceedings{10.1145/3062341.3062363,
author = {Haas, Andreas and Rossberg, Andreas and Schuff, Derek L. and Titzer, Ben L. and Holman, Michael and Gohman, Dan and Wagner, Luke and Zakai, Alon and Bastien, JF},
title = {Bringing the web up to speed with WebAssembly},
year = {2017},
isbn = {9781450349888},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3062341.3062363},
doi = {10.1145/3062341.3062363},
abstract = {The maturation of the Web platform has given rise to sophisticated and demanding Web applications such as interactive 3D visualization, audio and video software, and games. With that, efficiency and security of code on the Web has become more important than ever. Yet JavaScript as the only built-in language of the Web is not well-equipped to meet these requirements, especially as a compilation target. Engineers from the four major browser vendors have risen to the challenge and collaboratively designed a portable low-level bytecode called WebAssembly. It offers compact representation, efficient validation and compilation, and safe low to no-overhead execution. Rather than committing to a specific programming model, WebAssembly is an abstraction over modern hardware, making it language-, hardware-, and platform-independent, with use cases beyond just the Web. WebAssembly has been designed with a formal semantics from the start. We describe the motivation, design and formal semantics of WebAssembly and provide some preliminary experience with implementations.},
booktitle = {Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {185–200},
numpages = {16},
keywords = {assembly languages, just-in-time compilers, programming languages, type systems, virtual machines},
location = {Barcelona, Spain},
series = {PLDI 2017}
}

@article{10.1145/3140587.3062363,
author = {Haas, Andreas and Rossberg, Andreas and Schuff, Derek L. and Titzer, Ben L. and Holman, Michael and Gohman, Dan and Wagner, Luke and Zakai, Alon and Bastien, JF},
title = {Bringing the web up to speed with WebAssembly},
year = {2017},
issue_date = {June 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/3140587.3062363},
doi = {10.1145/3140587.3062363},
abstract = {The maturation of the Web platform has given rise to sophisticated and demanding Web applications such as interactive 3D visualization, audio and video software, and games. With that, efficiency and security of code on the Web has become more important than ever. Yet JavaScript as the only built-in language of the Web is not well-equipped to meet these requirements, especially as a compilation target. Engineers from the four major browser vendors have risen to the challenge and collaboratively designed a portable low-level bytecode called WebAssembly. It offers compact representation, efficient validation and compilation, and safe low to no-overhead execution. Rather than committing to a specific programming model, WebAssembly is an abstraction over modern hardware, making it language-, hardware-, and platform-independent, with use cases beyond just the Web. WebAssembly has been designed with a formal semantics from the start. We describe the motivation, design and formal semantics of WebAssembly and provide some preliminary experience with implementations.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {185–200},
numpages = {16},
keywords = {assembly languages, just-in-time compilers, programming languages, type systems, virtual machines}
}


@MISC{McCormickAnisotropicDiffusionLBR,
  title        = {Anisotropic Diffusion {LBR}},
  author       = {McCormick, Matthew},
  year         = {2015},
  url          = {https://insightsoftwareconsortium.github.io/ITKAnisotropicDiffusionLBR/},
  howpublished = {\url{https://insightsoftwareconsortium.github.io/ITKAnisotropicDiffusionLBR/}},
  note         = {Accessed: 2024-5-31},
  language     = {en}
}


@article{10.1145/3282510,
author = {Rossberg, Andreas and Titzer, Ben L. and Haas, Andreas and Schuff, Derek L. and Gohman, Dan and Wagner, Luke and Zakai, Alon and Bastien, J. F. and Holman, Michael},
title = {Bringing the web up to speed with WebAssembly},
year = {2018},
issue_date = {December 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {61},
number = {12},
issn = {0001-0782},
url = {https://doi.org/10.1145/3282510},
doi = {10.1145/3282510},
journal = {Commun. ACM},
month = {nov},
pages = {107–115},
numpages = {9}
}


@MISC{WasiDev,
  title        = "The WebAssembly System Interface (WASI)",
  abstract     = "The WebAssembly System Interface (WASI) is a group of
                  standard API specifications for software compiled to the W3C
                  WebAssembly (Wasm) standard. WASI is designed to provide a
                  secure standard interface for applications that can be
                  compiled to Wasm from any language, and that may run
                  anywhere---from browsers to clouds to embedded devices.",
  url          = "https://wasi.dev/",
  howpublished = "\url{https://wasi.dev/}",
  note         = "Accessed: 2024-5-31",
  language     = "en"
}

@inproceedings{10.1145/3572848.3577436,
author = {Chadha, Mohak and Krueger, Nils and John, Jophin and Jindal, Anshul and Gerndt, Michael and Benedict, Shajulin},
title = {Exploring the Use of WebAssembly in HPC},
year = {2023},
isbn = {9798400700156},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3572848.3577436},
doi = {10.1145/3572848.3577436},
abstract = {Containerization approaches based on namespaces offered by the Linux kernel have seen an increasing popularity in the HPC community both as a means to isolate applications and as a format to package and distribute them. However, their adoption and usage in HPC systems faces several challenges. These include difficulties in unprivileged running and building of scientific application container images directly on HPC resources, increasing heterogeneity of HPC architectures, and access to specialized networking libraries available only on HPC systems. These challenges of container-based HPC application development closely align with the several advantages that a new universal intermediate binary format called WebAssembly (Wasm) has to offer. These include a lightweight userspace isolation mechanism and portability across operating systems and processor architectures. In this paper, we explore the usage of Wasm as a distribution format for MPI-based HPC applications. To this end, we present MPIWasm, a novel Wasm embedder for MPI-based HPC applications that enables high-performance execution of Wasm code, has low-overhead for MPI calls, and supports high-performance networking interconnects present on HPC systems. We evaluate the performance and overhead of MPIWasm on a production HPC system and AWS Graviton2 nodes using standardized HPC benchmarks. Results from our experiments demonstrate that MPIWasm delivers competitive native application performance across all scenarios. Moreover, we observe that Wasm binaries are 139.5x smaller on average as compared to the statically-linked binaries for the different standardized benchmarks.},
booktitle = {Proceedings of the 28th ACM SIGPLAN Annual Symposium on Principles and Practice of Parallel Programming},
pages = {92–106},
numpages = {15},
keywords = {HPC, MPI, WebAssembly, wasm, wasmer},
location = {<conf-loc>, <city>Montreal</city>, <state>QC</state>, <country>Canada</country>, </conf-loc>},
series = {PPoPP '23}
}

@ARTICLE{Zhang2024-su,
  title         = "Research on {WebAssembly} Runtimes: A Survey",
  author        = "Zhang, Yixuan and Liu, Mugeng and Wang, Haoyu and Ma, Yun
                   and Huang, Gang and Liu, Xuanzhe",
  abstract      = "WebAssembly (abbreviated as Wasm) was initially introduced
                   for the Web but quickly extended its reach into various
                   domains beyond the Web. To create Wasm applications,
                   developers can compile high-level programming languages into
                   Wasm binaries or manually convert equivalent textual formats
                   into Wasm binaries. Regardless of whether it is utilized
                   within or outside the Web, the execution of Wasm binaries is
                   supported by the Wasm runtime. Such a runtime provides a
                   secure, memory-efficient, and sandboxed execution
                   environment designed explicitly for Wasm applications. This
                   paper provides a comprehensive survey of research on
                   WebAssembly runtimes. It covers 98 articles on WebAssembly
                   runtimes and characterizes existing studies from two
                   different angles, including the ``internal'' research of
                   Wasm runtimes(Wasm runtime design, testing, and analysis)
                   and the ``external'' research(applying Wasm runtimes to
                   various domains). This paper also proposes future research
                   directions about WebAssembly runtimes.",
  month         =  apr,
  year          =  2024,
  url           = "http://arxiv.org/abs/2404.12621",
  archivePrefix = "arXiv",
  eprint        = "2404.12621",
  primaryClass  = "cs.SE",
  arxivid       = "2404.12621"
}
